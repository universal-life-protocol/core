ULP v1.1 SEALED ARCHITECTURE SPECIFICATION
==========================================

Version: 1.1.0
Status: SEALED
Date: 2025-12-31
Canonical Definition: This file represents the immutable architecture


THE FIVE IMMUTABLE PRINCIPLES
==============================

Principle 1: Trace is Append-Only and Authoritative
---------------------------------------------------
Rule: The trace is the authoritative, append-only ground truth of execution
Implementation: Traces are write-once; no mutation after creation
Enforcement: Atomic mv operations, lock files, no sed/truncate
Consequence: Stable reference for reproducibility and projection

Principle 2: World Definition is Non-Executable
-----------------------------------------------
Rule: World definition files are non-executable descriptions
Implementation: .genesis/.env/.atom etc. contain identifier-only content
Enforcement: No control flow (if/while/for), no effects (exec/eval/>)
Consequence: What exists is separate from what happens

Principle 3: Projections are Pure Functions
-------------------------------------------
Rule: .projection functions are pure (Trace → View)
Implementation: Read-only functions, deterministic, no side effects
Enforcement: No exec/eval/system/write operations in projections
Consequence: Views cannot affect execution truth

Principle 4: Effects are Forward-Only via .interpose
----------------------------------------------------
Rule: .interpose may cause effects but may not read trace
Implementation: Declarative mapping: EVENT_TYPE -> EFFECT_SYMBOL
Enforcement: .interpose is data (mapping table), not code
Consequence: Prevents causal loops and observer influence

Principle 5: Information Flows Forward-Only
-------------------------------------------
Rule: World → Execution → Trace → Projection
Implementation: No backward references between layers
Enforcement: Validation checks for backward references
Consequence: Clean layering, no authority inversion


CLOSED VOCABULARY SETS
======================

World File Types (13 types)
---------------------------
.genesis    - Origin metadata (author, created, paradigm)
.env        - Environment constraints (inputs, outputs, effects)
.atom       - Primitive units (unit, encoding, normalization)
.manifest   - Component inventory
.schema     - Trace structure specification
.sequence   - Ordering constraints
.include    - Allowlist of interrupt names
.ignore     - Blocklist of interrupt names
.procedure  - Control flow patterns with Pattern_Syntax
.interrupt  - Event hooks (on_start, interrupt)
.interpose  - Effect mapping (EVENT -> SYMBOL)
.projection - Pure function declarations
.view       - Observer configuration

Trace Event Types (16 types)
----------------------------
HDR         - Header records (version, entry)
HEADER      - Legacy header format
WORLD       - World identification (wid, hash)
BEGIN       - Section begin marker
END         - Section end marker
INPUT       - Input data (stdin)
STDIN       - Input line record
CLAUSE      - Procedure clause (qid, signatures, interrupt)
EXEC        - Execution record (eid, wid, qid)
EVENT       - Generic event marker
INTERRUPT   - Interrupt execution record
OUTPUT      - Output data record
STDOUT      - Standard output line
STDERR      - Standard error line
EXIT        - Exit status record
PROCEDURE   - Procedure boundary marker

Self-Encoding Event Types (5 types)
-----------------------------------
MANIFEST    - Bundle manifest (sha256, count)
FILE        - File metadata (path, sha256, mode, bytes)
DATA        - Base64-encoded file content
END_FILE    - File boundary marker
SEAL        - Final integrity hash

Effect Symbols (13 symbols - CLOSED SET)
----------------------------------------
read_stdin      - Read from standard input
write_stdout    - Write to standard output
write_stderr    - Write to standard error
exit_with_code  - Terminate execution with code
open_file_r     - Open file for reading
create_file     - Create file with content
write_bytes     - Write bytes to file descriptor
close_fd        - Close file descriptor
fork_process    - Fork child process
allocate_memory - Allocate memory region
free_memory     - Free memory region
socket_create   - Create network socket (optional)
socket_connect  - Connect to endpoint (optional)

Projection Classes (16 classes)
-------------------------------
posix           - POSIX stdout view (lossy)
json            - JSON structured view (lossy)
pure            - Functional hash view (lossy)
graph           - Execution graph view (lossy)
w3c_html        - HTML rendering projection
w3c_dom         - DOM tree projection
w3c_css         - CSS layout projection
webgl_3d        - WebGL 3D projection
canvas_2d       - Canvas 2D projection
vulkan          - Vulkan rendering projection
bip32           - BIP32 identity projection
bip39           - BIP39 mnemonic projection
network_graph   - Network topology view
print           - PDF/print output
raw             - Raw trace view (lossless)
canonical       - Canonical semantic view


ARCHITECTURAL CONSTRAINTS
=========================

Trace Constraints
----------------
1. Append-only discipline (no mutation after write)
2. Tab-separated fields (TSV format)
3. UTF-8 encoding with NFC normalization
4. Self-encoding (traces contain execution environment)
5. Deterministic (same inputs → byte-identical traces)
6. No address literals (IP, port, MAC forbidden)
7. Trace-time ordering only (no wall-clock dependence)
8. Atomic completion (partial writes never visible)

World Constraints
----------------
1. Non-executable (data only, no control flow)
2. Identifier-only content (ASCII baseline: [A-Za-z_][A-Za-z0-9_:\-\.]*)
3. Finite and hashable (size bounded)
4. Canonicalizable (stable representation)
5. No effects (no exec/eval/system/>)
6. Declarative only (no if/while/for/case)

Projection Constraints
---------------------
1. Pure functions (deterministic, no side effects)
2. Read-only (cannot modify trace)
3. Lossy allowed (projections select/transform)
4. Composable forward-only (π₂ ∘ π₁, not backward)
5. No effects (no exec/eval/system/write)
6. Many views of same trace (interchangeable)

Effect Constraints
-----------------
1. Forward-only (World → Effects, never Effects → World)
2. Declarative mapping (.interpose is data, not code)
3. Closed set (no dynamic effect creation)
4. Validated against .network/.connections
5. Bounded execution (no Turing-completeness in effect layer)

Network Constraints (OPTIONAL)
------------------------------
1. Air-gapped by default (.network absent = no networking)
2. Declarative topology (.connections defines allowed endpoints)
3. No address literals in traces (endpoint references only)
4. Late binding (same trace works with different network configs)
5. Capability-based (must declare socket families and types)


INFORMATION FLOW MODEL
======================

Layer 1: World Definition (What Exists)
---------------------------------------
Files: .genesis, .env, .atom, .manifest, .schema, .sequence
Authority: Defines capabilities and constraints
Execution: Non-executable, identifier-only
Output: World ID (hash of canonical world)

Layer 2: Execution Structure (What Happens)
-------------------------------------------
Files: .procedure, .interrupt, .interpose
Authority: Controls trace construction
Execution: Interrupt handlers executed, events mapped to effects
Output: Trace events

Layer 3: Trace (What Happened - Ground Truth)
---------------------------------------------
Format: Tab-separated trace events
Authority: Authoritative record, single source of truth
Execution: Append-only construction
Output: Immutable trace file

Layer 4: Observation (How We See It)
------------------------------------
Files: .projection, .view
Authority: None (read-only views)
Execution: Pure functions applied to trace
Output: Various views (POSIX, JSON, W3C, BIP, etc.)

Information Flow: Layer 1 → Layer 2 → Layer 3 → Layer 4
Forbidden: Any backward references (4→3, 3→2, 2→1)


PATTERN_SYNTAX SPECIFICATION
============================

Procedure Definition Format
---------------------------
procedure <name>
<opening_delimiter_signature>
interrupt <interrupt_name>
<closing_delimiter_signature>

Multiset Validation Rule
------------------------
multiset(opening_signature) == multiset(closing_signature)

Example:
  Opening:  (([
  Closing:  [((
  Multiset: {(, (, [} == {[, (, (}  ✓ VALID

Implementation:
  Sort characters in both signatures
  Compare sorted strings for equality
  Order-insensitive, character-frequency sensitive


TRACE FORMAT SPECIFICATION
==========================

Field Structure
--------------
Format: <EVENT_TYPE>\t<key1>\t<value1>\t<key2>\t<value2>\t...
Separator: Tab character (0x09)
Encoding: UTF-8, NFC normalized
Escaping: \\ → \, \t → tab, \n → newline, \r → CR

Header Section
-------------
HDR\tversion\t1
HDR\tentry\t<entry_procedure_name>
WORLD\twid\t<world_hash_sha256>

Input Section
------------
STDIN\tn\t<line_number>\ttext\t<escaped_text>

Execution Section
----------------
CLAUSE\tqid\t<clause_hash>\topenSig\t<sig>\tcloseSig\t<sig>\tintr\t<name>
EXEC\teid\t<exec_hash>\twid\t<world_hash>\tqid\t<clause_hash>\tintr\t<name>
STDOUT\tn\t<line_number>\ttext\t<escaped_text>
STDERR\tn\t<line_number>\ttext\t<escaped_text>
EXIT\tintr\t<interrupt_name>\tcode\t<exit_code>

Completion Marker
----------------
END\tok\t1

Self-Encoding Bundle
-------------------
MANIFEST\tsha256\t<manifest_hash>\tcount\t<file_count>
FILE\tpath\t<virtual_path>\tsha256\t<file_hash>\tmode\t<octal>\tbytes\t<size>
DATA\t<base64_line_76chars>
...
END_FILE\tpath\t<virtual_path>

Virtual Path Prefixes
---------------------
WORLD/     - World definition files
REPO/bin/  - Core utilities (.sh, .awk)
REPO/interrupts/ - Interrupt handlers


HASH CALCULATIONS
=================

World Hash (WID)
---------------
Input: Canonicalized world files (.genesis, .env, .atom, etc.)
Algorithm: SHA-256
Format: Hex string (64 characters)
Purpose: Identifies world definition uniquely

Clause Hash (QID)
----------------
Input: "Q|OPEN=<openSig>|INT=<interrupt>|CLOSE=<closeSig>"
Algorithm: SHA-256
Format: Hex string (64 characters)
Purpose: Identifies procedure clause uniquely

Execution Hash (EID)
-------------------
Input: "E|W=<wid>|Q=<qid>|INT=<interrupt>"
Algorithm: SHA-256
Format: Hex string (64 characters)
Purpose: Identifies execution instance uniquely

Manifest Hash
------------
Input: For each file: "<vpath>\0<sha256>\0<mode>\0<bytes>\n"
Algorithm: SHA-256
Format: Hex string (64 characters)
Purpose: Verifies self-encoding bundle integrity


DETERMINISM GUARANTEES
======================

Input Determinism
----------------
Same stdin → same INPUT records
Line-by-line recording with stable encoding

Execution Determinism
--------------------
Same world + same input → same trace events
No wall-clock time, no randomness, no network variance

Hash Determinism
---------------
Same content → same SHA-256 hash
Canonical ordering, stable representation

Reconstruction Determinism
-------------------------
Trace → reconstructed files → same trace
Self-encoding bundle contains complete environment


SECURITY MODEL
==============

Capability-Based Security
-------------------------
1. Declarative permissions (.network, .connections)
2. No capability escalation (closed effect set)
3. Air-gapped by default (networking opt-in)
4. Allowlist-based (.include required for interrupts)

Sandboxing
---------
1. World files non-executable (cannot hide malware)
2. Interrupts validated against .include/.ignore
3. Effects bounded (no Turing-completeness)
4. No eval/exec in projections

Audit Trail
----------
1. Complete trace of all events
2. Cryptographic integrity (SEAL hash)
3. Immutable (append-only)
4. Self-contained (includes execution environment)


CHANGE POLICY
=============

Allowed Changes (within v1.1)
----------------------------
- Bug fixes that preserve semantics
- Performance optimizations
- Documentation improvements
- New projection implementations (from closed set)
- Additional validation checks
- Tooling improvements

Prohibited Changes (require v2.0)
--------------------------------
- Modifying the five principles
- Extending vocabulary sets
- Making traces mutable
- Adding effects to projections
- Making world definitions executable
- Creating backward information flow
- Adding new event types
- Adding new effect symbols
- Relaxing constraints


IMPLEMENTATION REQUIREMENTS
===========================

Required Tools
-------------
- awk (POSIX-compliant)
- sh (POSIX shell)
- sort (for multiset validation)
- base64 (for encoding/decoding)
- sha256sum OR shasum OR openssl (for hashing)

Required Scripts
---------------
bin/run.sh              - Main execution engine
bin/hash.sh             - Portable SHA-256 hashing
bin/canon.awk           - Canonicalization
bin/proc.awk            - Procedure parsing with multiset validation
bin/self_encode.sh      - Self-encoding bundle creation
bin/decode_trace.sh     - Trace reconstruction
bin/observe.sh          - Projection application
bin/trace.awk           - Trace formatting utilities

Validation Scripts
-----------------
bin/validate_world.sh       - World invariant validation
bin/validate_interpose.sh   - Effect mapping validation
bin/enforce_invariants.sh   - Complete invariant check
bin/verify_architecture.sh  - Architecture verification


MATHEMATICAL PROPERTIES
=======================

Trace as Ground Truth
--------------------
∀ execution e, ∃! trace t : Execute(w, i) = t
(For any execution, there exists a unique authoritative trace)

Projection Purity
----------------
∀ traces t₁ t₂, t₁ = t₂ ⟹ π(t₁) = π(t₂)
(Pure projections are deterministic functions)

Forward-Only Composition
-----------------------
π₃ ∘ π₂ ∘ π₁ is valid
π₁ ∘ π₂ ∘ π₃ is forbidden (backward composition)

Information Monotonicity
-----------------------
Layer₍ₙ₎ may reference Layer₍ₙ₋₁₎, Layer₍ₙ₋₂₎, ..., Layer₍₁₎
Layer₍ₙ₎ may NOT reference Layer₍ₙ₊₁₎, Layer₍ₙ₊₂₎, ...

Deterministic Replay
-------------------
Trace(Execute(w, i)) = t ⟹ Trace(Execute(w, i)) = t
(Repeated execution produces identical traces)


ARCHITECTURE COMPLETION
=======================

This specification is COMPLETE and SEALED as of version 1.1.0.

Any modification to:
- The five principles
- Vocabulary sets
- Architectural constraints
- Information flow model
- Trace format
- Hash calculations
- Security model

...requires a new major version (2.0.0) with formal proposal and review.

The architecture is frozen to preserve the fundamental insight:

  "The trace is the machine. Everything else is a view."

This ensures that:
1. Execution is transparent (no hidden behaviors)
2. Systems are deterministic (no "works on my machine")
3. Software is preservable (no bit-rot)
4. Users are sovereign (no platform lock-in)
5. Innovation is bounded (within sealed foundations)


END OF CANONICAL SPECIFICATION
==============================
